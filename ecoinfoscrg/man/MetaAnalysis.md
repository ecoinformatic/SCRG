# Meta-Analysis Workflow

The scripts below use the output from the workflow documented in `ModelSelection.df` to process data for meta-analytic regressions.

The following packages are required:
* `dplyr`
* `metafor`
* `Matrix`

## A.5: Constructing Well-Conditioned Uncertainty Matrices
For each local study, missing parameter estimates are replaced with sample means. Missing covariances in the covariance matrix of parameters are set to 0, and missing variances are set to large values. This aids in maintaining matrix stability.

### Retrieve Betas from Model Output (`getBetas.R`)
The following script retrieves the parameter estimates generated by the `BUPD.R` script and creates a dataset with those betas listed in column which their respective response variables in rows. There are two primary outputs:
* `combined_betas`: contains parameter estimates and columns containin info regarding the model, study, and Intercept.
* `combined_betas_only`: contains only parameter estimates (model, study, and Intercept are removed)

```{R, echo=FALSE}
library(dplyr)

############################
# GRAB MODEL OUTPUT
############################
source("scripts/wranglingCleaning.R")
source("scripts/standardize.R")

chocBetas <- readRDS("output/chocContinuous_average_betas.rds")
pensBetas <- readRDS("output/pensContinuous_average_betas.rds")
IRLBetas <- readRDS("output/IRLContinuous_average_betas.rds")
tampaBetas <- readRDS("output/tampaContinuous_average_betas.rds")

# Get predictors (excluding study and definitions)
numeric_pred <- pred %>%
  select_if(is.numeric)
numeric_pred_cols <- colnames(numeric_pred)

# Function to convert model out put to dataframe (only keep "Estimate")
prepare_df <- function(matrix, source) {
    df <- as.data.frame(t(matrix))
    df <- df[1, , drop = FALSE] # Keep "Estimate"
    colnames(df) <- rownames(matrix)
    missing_cols <- setdiff(numeric_pred_cols, rownames(matrix)) # missing predictors as NA
    df[missing_cols] <- NA
    df <- df[, numeric_pred_cols] # order columns
    df$study <- source
    return(df)
}

chocDF <- prepare_df(chocBetas, "choc")
pensDF <- prepare_df(pensBetas, "pens")
tampaDF <- prepare_df(tampaBetas, "tampa")
IRLDF <- prepare_df(IRLBetas, "IRL")

# Combine all dataframes
combined_betas <- rbind(chocDF, pensDF, tampaDF, IRLDF)
combined_betas[] <- lapply(combined_betas, function(x) as.numeric(as.character(x))) # will probably get NAs

# Get column names from pred
missing_cols <- setdiff(numeric_pred_cols, colnames(combined_betas))
combined_betas[missing_cols] <- NA


############################
# GENERATE AVERAGES AND REPLACE NA's WITH THEM
############################
# Get average for each row ignore NA
combined_betas[] <- lapply(combined_betas, function(x) as.numeric(as.character(x)))
row_averages <- apply(combined_betas, 1, function(row) mean(row, na.rm = TRUE))

choc_avg <- row_averages[1]
pens_avg <- row_averages[2]
tampa_avg <- row_averages[3]
IRL_avg <- row_averages[4]

choc_avg
pens_avg
tampa_avg
IRL_avg

# Replace NAs
combined_betas[1, ][is.na(combined_betas[1, ])] <- choc_avg
combined_betas[2, ][is.na(combined_betas[2, ])] <- pens_avg
combined_betas[3, ][is.na(combined_betas[3, ])] <- tampa_avg
combined_betas[4, ][is.na(combined_betas[4, ])] <- IRL_avg

################################
# SCALE BETAS TO REFERENCE STUDY
################################
# Tampa as reference
reference_study <- combined_betas[3, ]
# str(reference_study, list.len=ncol(reference_study))

for (i in 2:(ncol(combined_betas))) { # the last column is the study
  reference_value <- as.numeric(reference_study[i])

  # Scale columns by reference study's beta value
  combined_betas[, i] <- combined_betas[, i] / reference_value
}

# add study column (optional)
combined_betas$study <- c("choc", "pens", "tampa", "IRL")
# Remove study columned
combined_betas_only <- combined_betas[, !colnames(combined_betas) %in% "study"]
View(combined_betas_only)

################################
# EXTRA: SE (for effect size)
################################
# Function to convert model out put to dataframe (only keep "Estimate")
prepare_se_df <- function(matrix, source) {
    df <- as.data.frame(t(matrix))
    df <- df[2, , drop = FALSE] # Keep "Estimate"
    colnames(df) <- rownames(matrix)
    missing_cols <- setdiff(numeric_pred_cols, rownames(matrix)) # missing predictors as NA
    df[missing_cols] <- NA
    df <- df[, numeric_pred_cols] # order columns
    df$study <- source
    return(df)
}

chocDF_se <- prepare_df(chocBetas, "choc")
pensDF_se <- prepare_df(pensBetas, "pens")
tampaDF_se <- prepare_df(tampaBetas, "tampa")
IRLDF_se <- prepare_df(IRLBetas, "IRL")

combined_se <- rbind(chocDF_se, pensDF_se, tampaDF_se, IRLDF_se)
combined_se[] <- lapply(combined_se, function(x) as.numeric(as.character(x)))

row_averages_se <- apply(combined_se, 1, function(row) mean(row, na.rm = TRUE))

choc_avg_se <- row_averages_se[1]
pens_avg_se <- row_averages_se[2]
tampa_avg_se <- row_averages_se[3]
IRL_avg_se <- row_averages_se[4]

# Replace NAs
combined_se[1, ][is.na(combined_se[1, ])] <- choc_avg_se
combined_se[2, ][is.na(combined_se[2, ])] <- pens_avg_se
combined_se[3, ][is.na(combined_se[3, ])] <- tampa_avg_se
combined_se[4, ][is.na(combined_se[4, ])] <- IRL_avg_se

combined_betas$study <- c("choc", "pens", "tampa", "IRL")
# View(combined_se)

# remove study column
combined_se_only <- combined_se[, !colnames(combined_se) %in% "study"]
```

### Generate Variance-Covariance Matrix (`varCov.R`)
The following script using the `cov()` function in R to generate a variance-covaraince matrix for the parameter estimates(betas). It replaces missing betas for a study (that were pruned out during model selection) with the mean value for that study. It also replaces missing covariance values with zeros (i.e., no known relationship between parameters) and missing variance values with an arbritrarily high value (high possible range of effects of that parameter on the outcome).

```{R, echo=FALSE}
# Generate covariance matrix
cov_matrix <- cov(combined_betas_only, use = "pairwise.complete.obs")

# Find where there's missing values
missing_values <- is.na(cov_matrix)

# Set missing off-diagonals to zero
cov_matrix[missing_values & !row(cov_matrix) == col(cov_matrix)] <- 0

# Set missing variances to very large value
large_value <- 10000
diag(cov_matrix)[missing_values[diag(TRUE, nrow(cov_matrix))]] <- large_value
```

## Calculate Effect Size
The following script is used to calculate effect sizes which can be used in the meta-analytic regression.

```{R, echo=FALSE}
# Number of columns
num_columns <- ncol(combined_betas_only)

# Initialize vectors to store overall effect sizes and their standard errors
overall_effect <- numeric(num_columns)
overall_standard_error <- numeric(num_columns)

# Loop over each column
for (i in 1:num_columns) {
  estimates <- combined_betas_only[, i]
  standard_errors <- combined_se_only[, i]

  # Calculate variances
  variances <- standard_errors^2

  # Calculate weights
  weights <- 1 / variances

  # Calculate the weighted mean effect size
  weighted_mean <- sum(weights * estimates) / sum(weights)

  # Calculate the variance of the combined effect size
  combined_variance <- 1 / sum(weights)

  # Calculate the standard error of the combined effect size
  combined_standard_error <- sqrt(combined_variance)

  # Store the results
  overall_effect[i] <- weighted_mean
  overall_standard_error[i] <- combined_standard_error
}
```

## A.6: Meta-Analytic Regression
The following script uses the `metafor` package in R to perform meta-analytic regression.
* Add info about matrix solvers and necessary lines to get them to work

```{R, echo=FALSE}
# TBD
```
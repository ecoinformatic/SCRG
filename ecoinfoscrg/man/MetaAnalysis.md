# Meta-Analysis Workflow

The scripts below use the output from the workflow documented in `ModelSelection.df` to process data for meta-analytic regressions.

The following packages are required:
* `dplyr`
* `metafor`
* `Matrix`

## A.5: Constructing Well-Conditioned Uncertainty Matrices
For each local study, missing parameter estimates are replaced with sample means. Missing covariances in the covariance matrix of parameters are set to 0, and missing variances are set to large values. This aids in maintaining matrix stability.

### Retrieve Betas from Model Output (`getBetas.R`)
The following script retrieves the parameter estimates generated by the `BUPD.R` script and creates a dataset with those betas listed in column which their respective response variables in rows. There are two primary outputs:
* `combined_betas`: contains parameter estimates and columns containin info regarding the model, study, and Intercept.
* `combined_betas_only`: contains only parameter estimates (model, study, and Intercept are removed)

```{R, echo=FALSE}
library(dplyr)

############################
# GRAB MODEL OUTPUT
############################
source("scripts/wranglingCleaning.R")
source("scripts/standardize.R")

chocBetas <- readRDS("output/chocContinuous_average_betas.rds")
pensBetas <- readRDS("output/pensContinuous_average_betas.rds")
IRLBetas <- readRDS("output/IRLContinuous_average_betas.rds")
tampaBetas <- readRDS("output/tampaContinuous_average_betas.rds")

# Get predictors (excluding study and definitions)
numeric_pred <- pred %>%
  select_if(is.numeric)
numeric_pred_cols <- colnames(numeric_pred)

# Function to convert model out put to dataframe (only keep "Estimate")
prepare_df <- function(matrix, source) {
    df <- as.data.frame(t(matrix))
    df <- df[1, , drop = FALSE] # Keep "Estimate"
    colnames(df) <- rownames(matrix)
    missing_cols <- setdiff(numeric_pred_cols, rownames(matrix)) # missing predictors as NA
    df[missing_cols] <- NA
    df <- df[, numeric_pred_cols] # order columns
    df$study <- source
    return(df)
}

chocDF <- prepare_df(chocBetas, "choc")
pensDF <- prepare_df(pensBetas, "pens")
tampaDF <- prepare_df(tampaBetas, "tampa")
IRLDF <- prepare_df(IRLBetas, "IRL")

# Combine all dataframes
combined_betas <- rbind(chocDF, pensDF, tampaDF, IRLDF)
combined_betas[] <- lapply(combined_betas, function(x) as.numeric(as.character(x))) # will probably get NAs

# Get column names from pred
missing_cols <- setdiff(numeric_pred_cols, colnames(combined_betas))
combined_betas[missing_cols] <- NA


############################
# GENERATE AVERAGES AND REPLACE NA's WITH THEM
############################
# Get average for each row ignore NA
combined_betas[] <- lapply(combined_betas, function(x) as.numeric(as.character(x)))
row_averages <- apply(combined_betas, 1, function(row) mean(row, na.rm = TRUE))

choc_avg <- row_averages[1]
pens_avg <- row_averages[2]
tampa_avg <- row_averages[3]
IRL_avg <- row_averages[4]

choc_avg
pens_avg
tampa_avg
IRL_avg

# Replace NAs
combined_betas[1, ][is.na(combined_betas[1, ])] <- choc_avg
combined_betas[2, ][is.na(combined_betas[2, ])] <- pens_avg
combined_betas[3, ][is.na(combined_betas[3, ])] <- tampa_avg
combined_betas[4, ][is.na(combined_betas[4, ])] <- IRL_avg

################################
# SCALE BETAS TO REFERENCE STUDY
################################
# Tampa as reference
reference_study <- combined_betas[3, ]
# str(reference_study, list.len=ncol(reference_study))

for (i in 2:(ncol(combined_betas))) { # the last column is the study
  reference_value <- as.numeric(reference_study[i])

  # Scale columns by reference study's beta value
  combined_betas[, i] <- combined_betas[, i] / reference_value
}

# add study column (optional)
combined_betas$study <- c("choc", "pens", "tampa", "IRL")
# Remove study columned
combined_betas_only <- combined_betas[, !colnames(combined_betas) %in% "study"]
View(combined_betas_only)

################################
# EXTRA: SE (for effect size)
################################
# Function to convert model out put to dataframe (only keep "Estimate")
prepare_se_df <- function(matrix, source) {
    df <- as.data.frame(t(matrix))
    df <- df[2, , drop = FALSE] # Keep "Estimate"
    colnames(df) <- rownames(matrix)
    missing_cols <- setdiff(numeric_pred_cols, rownames(matrix)) # missing predictors as NA
    df[missing_cols] <- NA
    df <- df[, numeric_pred_cols] # order columns
    df$study <- source
    return(df)
}

chocDF_se <- prepare_df(chocBetas, "choc")
pensDF_se <- prepare_df(pensBetas, "pens")
tampaDF_se <- prepare_df(tampaBetas, "tampa")
IRLDF_se <- prepare_df(IRLBetas, "IRL")

combined_se <- rbind(chocDF_se, pensDF_se, tampaDF_se, IRLDF_se)
combined_se[] <- lapply(combined_se, function(x) as.numeric(as.character(x)))

row_averages_se <- apply(combined_se, 1, function(row) mean(row, na.rm = TRUE))

choc_avg_se <- row_averages_se[1]
pens_avg_se <- row_averages_se[2]
tampa_avg_se <- row_averages_se[3]
IRL_avg_se <- row_averages_se[4]

# Replace NAs
combined_se[1, ][is.na(combined_se[1, ])] <- choc_avg_se
combined_se[2, ][is.na(combined_se[2, ])] <- pens_avg_se
combined_se[3, ][is.na(combined_se[3, ])] <- tampa_avg_se
combined_se[4, ][is.na(combined_se[4, ])] <- IRL_avg_se

combined_betas$study <- c("choc", "pens", "tampa", "IRL")
# View(combined_se)

# remove study column
combined_se_only <- combined_se[, !colnames(combined_se) %in% "study"]
```

### Generate Variance-Covariance Matrix (`varCov.R`)
The following script using the `cov()` function in R to generate a variance-covaraince matrix for the parameter estimates(betas). It replaces missing betas for a study (that were pruned out during model selection) with the mean value for that study. It also replaces missing covariance values with zeros (i.e., no known relationship between parameters) and missing variance values with an arbritrarily high value (high possible range of effects of that parameter on the outcome).

```{R, echo=FALSE}
# Generate covariance matrix
cov_matrix <- cov(combined_betas_only, use = "pairwise.complete.obs")

# Find where there's missing values
missing_values <- is.na(cov_matrix)

# Set missing off-diagonals to zero
cov_matrix[missing_values & !row(cov_matrix) == col(cov_matrix)] <- 0

# Set missing variances to very large value
large_value <- 10000
diag(cov_matrix)[missing_values[diag(TRUE, nrow(cov_matrix))]] <- large_value
```

## A.6: Meta-Analytic Regression (`metafor.R`)
The following script uses the `metafor` package in R to perform meta-analytic regression.

### Data Prep
Used to retrieve input data for meta-analytic regression and prepare matrices.
* To_do: Add info about matrix solvers from meta.docx and necessary lines to get them to work

```{R, echo=FALSE}
library(metafor)
library(Matrix)

source("ecoinfoscrg/R/getBetas.R")
source("ecoinfoscrg/R/varCov.R")

# Model output for each study can be found here:
chocBetas <- readRDS("output/chocContinuous_average_betas.rds")
pensBetas <- readRDS("output/pensContinuous_average_betas.rds")
IRLBetas <- readRDS("output/IRLContinuous_average_betas.rds")
tampaBetas <- readRDS("output/tampaContinuous_average_betas.rds")

###############
# Define predictor columns
predictor_columns <- colnames(combined_betas_only)

# Create the formula string dynamically
formula_string <- paste("~", paste(predictor_columns, collapse = " + "))
formula <- as.formula(formula_string)

# Prepare the beta estimates
betas <- combined_betas_only


###########
eigen_decomp <- eigen(cov_matrix)
eigenvalues <- eigen_decomp$values
eigenvectors <- eigen_decomp$vectors

# Find the smallest positive eigenvalue
smallest_eigenvalue <- min(eigenvalues[eigenvalues > 0])

# # Define the maximum allowed variance
# max_allowed_variance <- sqrt(1 / .Machine$double.eps) * smallest_eigenvalue

# Adjust eigenvalues
adjusted_eigenvalues <- pmax(eigenvalues, (.Machine$double.eps)^(1/3))
adjusted_eigenvalues <- pmin(eigenvalues, (.Machine$double.eps)^(-1/3))
# adjusted_eigenvalues <- pmin(eigenvalues, max_allowed_variance)

# adjusted_eigenvalues <- pmax(adjusted_eigenvalues, (.Machine$double.eps)^(1/3))
# adjusted_eigenvalues <- pmin(adjusted_eigenvalues, (.Machine$double.eps)^(-1/3))
adjusted_cov_matrix <- eigenvectors %*% diag(adjusted_eigenvalues) %*% t(eigenvectors)

# another check
smallest_eigenvalue <- min(adjusted_eigenvalues[adjusted_eigenvalues > 0])
smallest_eigenvalue

#####
# Recommendation: Add a small jitter to the diagonal to ensure positive definiteness
epsilon <- 1e-6
adjusted_cov_matrix <- adjusted_cov_matrix + diag(epsilon, nrow(adjusted_cov_matrix))
#####
```

### Meta-Analytic Regression 
```{R, echo=FALSE}
##############################
# Meta-Analytic Regression
##############################
# Note: Testing with betas but need effect sizes (e.g. odd ratios) from BUPD.R model output

# Flatten beta coefficients
betas_vector <- as.vector(t(combined_betas_only))

# Get study vector corresponding to each beta (required for study random effect)
study_labels <- c("choc", "pens", "tampa", "IRL") # will need to change labels as more data is available
study_vector <- rep(study_labels, each = ncol(combined_betas_only))

# specify input data
beta = betas_vector
study = factor(study_vector)
predictor = rep(colnames(combined_betas_only), times = length(study_labels))
variance <- diag(cov_matrix)

# run metafor meta-analytic regression
result <- rma.mv(
  yi = beta, # Vector of all beta coefficients (may need effect size e.g. odds ratios from BUPD.R output instead)
  V = variance, # vector of length k with the corresponding sampling variances or a k x k variance-covariance matrix of the sampling errors
  method = "REML", # default
  random = ~ 1 | study, # Random effects for studies
  mods = ~ 0 + predictor # Including predictors as fixed effects without an intercept (AKA is predictors in formula)
) 

summary(result)

```